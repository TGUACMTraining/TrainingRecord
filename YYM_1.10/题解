复数用法 complex<类型> 变量名
通过.real() .imag()访问实部和虚部

不知道为什么，自己写出来的将文件按行输出的程序运行总有bug，可能原因是编码问题
但是一个字一个字的判断是可以正常运行的

 曼哈顿距离:一个点到一条斜率为=-1的直线上的距离是相同的不变的

 快速分解质因数的方法:先算出素数，原数除以这些数，把结果插入set中

 打表太长会无法提交

  while(~scnaf()){
}

使用迭代器对set进行遍历

使用 long long 来防止整数溢出{这周两次遇到了整数溢出了}

求一个随机序列中最多有几个不上升子序列
应该是求上升子序列的长度
通过不断去除最长不上升子序列的方法是错的

原数组o_arr 新数组n_arr 原数组长o_length 新数组长n_length
1.使n_arr[0]=o_arr[0]
2.遍历o_arr {
            如果o_arr[i]<=n_arr[n_length-1],就直接n_arr[n_length++]=o_arr[i];
            否则，将*upper_bound(n_arr,n_arr+n_length,o_arr[i],greater<int>())替换成o_arr[i];
        }
        (
            例:1924267297
            1
            9
            92
            94
            942
            962
            972
            9722
            9922
            9972
            即优先保证数组的增长，否则将新元素尽量向做替换
        )
greater<int >对象可以被转换成函数 greater<int >()

求公共序列只需要根据原序列构建一个映射关系，使原序列变得单调递增
更新后来的序列，求出其单增最长子序列就行        

有时可以通过遍历的方法避免边界问题，这样虽然慢一点，但理论上不会tle，却可以大幅提高正确率
在整数达到一定精度的时候跳出循环，开始遍历，然后用upper_bound,lower_bound即可