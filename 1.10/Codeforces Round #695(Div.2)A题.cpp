//A.Wizard of Orz
//
#include<stdio.h>
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n;
		scanf("%d",&n);
		if(n==1) printf("9");
		else if(n==2) printf("98");
		else if(n==3) printf("989");
		else
		{
			int sum=n-3;
			printf("989");
			if(sum<=10)
			for(int i=0;sum>0;sum--)
			{
				printf("%d",i);
				i++;
				if(i==10) i=0;
			}
			else
			{
				int a=sum/10,b=sum%10;
				for(int i=0;i<a;i++)
				printf("0123456789");
				for(int i=0;i<b;i++)
				printf("%d",i);
			}
		}
		printf("\n");
	}
	return 0;
}
//题目大意：有n块面板，每块面板都能显示0~9的数字，初始时
//面板上的数字都为0，每过一秒，面板上的数字都加一，如0 →1，
//1 →2，以此类推。现在我们能够在任何时候暂停其中一块面板，
//然后，与它相邻的面板则会在下一秒被自动暂停，这这块与之
//相邻的面板的相邻面板则会在第二秒被自动暂停。换一种说法，
//如果你暂停了第x块面板，第y块面板(对所有有效的y)将会在
//|x-y|秒后被暂停。例如，现在有四块板，如果你在第三块面板
//显示数字为9时暂停，那么，第一块面板将会在两秒后暂停，数字
//是1，第二块面板将会在一秒后暂停，数字是0，第四块面板将会
//在一秒后暂停，数字是0。(注意暂停后数字不会再改变)
//所以最终显示的结果是1090(从左往右读)，但这并不是我们想要的。
//我们的目标是，当做出暂停这个操作后，最终显示在面板上的数字
//串(从左往右读)是所能得到的数字中最大的。
//输入
//2
//1
//2
//输出
//9
//98
//
//思路：要保证最终显示的数最大，只需保证最高位数字尽可能大即可
//所以从左往右，第一位必定是9，分析可得，要得到9有两种方法，一
//是在第一块板为9时暂停，或者在第二位为八时，让第二块板暂停。
//故第二块面板必定为8，同理，8也可由第2块在8时暂停，也可以由
//第三块板子在7时暂停得到。以此类推。由于要尽可能保证最高位数字
//最大，所以发现最终得到的数字即为9890123456789012…
//最后根据面板数目输出即可。
