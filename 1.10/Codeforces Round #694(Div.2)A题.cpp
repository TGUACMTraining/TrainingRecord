//A.Strange Partition
//
#include<stdio.h>
int main()
{
	int t,n,x;long long int a[100010];
	scanf("%d",&t);
	while(t--)
	{
		long long int min=0,max=0,i;
		scanf("%d %d",&n,&x);
		for(i=0;i<n;i++)
		scanf("%lld",&a[i]);
		for(i=0;i<n;i++)
		{
			max+=(a[i]/x);
			if(a[i]%x) max++;
		}
		for(i=0;i<n;i++)
		{
			min+=a[i];
		}
		long long int min1=min;
		min/=x;
		if(min1%x) min++;
		printf("%lld %lld\n",min,max);
	}
	return 0;
}
//
//题目大意：给定一个长度为n的数组a和一个整数x。你可以执行以下
//操作任意次数(可能为0):用数组中相邻的两个元素的和替换它们。
//例如，如果初始数组是[3,6,9]，在一个操作中，可以用它们的和替换
//最后两个元素，生成一个数组[3,15]，或者替换前两个元素得到一个
//数组[9,9]。注意，每次操作之后数组的大小都会减小。
//数组的美丽b = (b1,…,bk)被定义为∑k i = 1[bi/x],这意味着我们
//将每个元素除以x,四舍五入到最接近的整数,并将加起来作为结果值。
//例如,如果x=3,数组(4、11、6),数组的美等于4/3+11/3+6/3=2+4+2=8。
//请确定通过对原始数组执行一些操作可以得到的最小值和最大值。
//输入
//第一个输入行包含一个整数t 测试用例的数量(1 ≤t≤1000)。
//每个测试用例的第一行包含两个整数n和x(1 ≤n ≤105,1 ≤x ≤109)。
//下一行包含n个整数a1,a2，…，an(1 ≤ai ≤109)，数组a的元素。
//保证所有测试用例中n的值之和不超过105。
//输出
//对于每个测试用例输出两个整数——可能的最大值和最小值。
//
//解题思路：
//读完题目后，理解到其中所说的最大值即将每个数除以x后累加而得，
//做除法时如果不能整除，则对结果取整数部分并加上1
//最小值可由所有的数加起来，然后除以x并对结果取整，如果不能
//整除，则对结果加1，结果即为所得。
//实际做题时，由于没有考虑到当所给的数足够大时，容易爆int，导致
//思路对了却总在第三个测试点WA了。后来查看了测试数据才意识到可能
//爆了。改为long long int 就AC了。
