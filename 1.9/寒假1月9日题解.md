## AcWing 898. 数字三角形
线性dp的第一道题目, 数字三角形
之前也有见到过类似的题目, 学过后思路一下被拓宽了
采用的方法是用f(i,j)表示到(i,j)所有路径的最大值, 这样只要O(n2)的复杂度就可以完成所有位置的最值的更改
另外分别采用两种方法解决这道题
1. 采用从上到下的方法时, 最边的位置要和不存在的位置比较, 因此需要初始化成负无穷, 并且初始化的范围要尽可能大一些, 防止出现负数的情况出错, 且最后得到结果还需要遍历最后一排
2. 采用从下到上的方法时, 只需要把f数组的最后一排初始化成, 不需要初始化其他位置, 最后结果就是f(1,1), 虽然绕了一个弯, 但是更推荐这种方法.

## AcWing 895. 最长上升子序列
f(i)中存的是所有以i结尾的序列中, 最长的上升序列
对每一个位置从前往后遍历这个序列, 每次都能得到当前位置的最长上升子序列, 直到最后一个位置
时间复杂度O(n^2)

## AcWing 897. 最长公共子序列
最长公共子序列的题目, 蓝桥杯中见过一个类似的, 具体思路如下:
1. 遍历a字符串和b字符串的每一位, 对于每一个f(i,j), 均分为四种情况: 选a选b, 选a不选b, 不选a选b, 不选a不选b
2. 对于每种情况, 分别用f对应的值来表示, 其中不选a不选b的情况包含在了中间两种里, 而既选a又选b的情况需要二者相等

## AcWing 282. 石子合并
区间dp的第一道题目, 还是比较难以理解的
首先要储存下来前缀和数组, 根据选择区间的长短分为最外层的len2~n
之后枚举起点i, 确定起点后可以根据长度和起点确定左右端点坐标
接着枚举左右端点内的所有可能的断点, 根据这些断点的左右两边代价之和, **利用前缀和数组求出所确定左右端点内的最小代价**
