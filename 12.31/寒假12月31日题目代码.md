## AcWing 873. 欧拉函数
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

int phi(int n)
{
    int res = n;
    for (int i = 2; i <= n / i; i ++)
    {
        if (n % i == 0)
        {
            res = res / i * (i - 1);
            while (n % i == 0)
            {
                n /= i;
            }
        }
    }
    if (n > 1)  res = res / n * (n - 1);
    
    return res;
}

int main(void)
{
    int n;
    cin >> n;
    while (n --)
    {
        int x;
        scanf("%d", &x);
        printf("%d\n", phi(x));
    }
    
    return 0;
}
```

## AcWing 874. 筛法求欧拉函数
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

typedef long long ll;
const int N = 1000010;

int primes[N], cnt;
bool st[N];
int phi[N];

ll get_euler(int n)
{
    phi[1] = 1;
    for (int i = 2; i <= n; i ++)
    {
        if (!st[i])
        {
            primes[cnt ++] = i;
            phi[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++)
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                phi[t] = phi[i] * primes[j];
                break;
            }
            phi[t] = phi[i] * (primes[j] - 1);
        }
    }
    
    ll res = 0;
    for (int i = 1; i <= n; i ++)   res += phi[i];
    return res;
}

int main(void)
{
    int n;
    cin >> n;
    cout << get_euler(n) << endl;
    
    return 0;
}
```
## AcWing 875. 快速幂
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

typedef long long ll;

ll pmi(ll a, ll k, ll p)
{
    ll res = 1;
    while (k)
    {
        if (k & 1)  res = res * a % p;
        k >>= 1;
        a = a * a % p;
    }
    return res;
}

int main(void)
{
    int n;
    scanf("%d", &n);
    while (n --)
    {
        ll a, k, p;
        scanf("%lld%lld%lld", &a, &k, &p);
        printf("%lld\n", pmi(a, k, p));
    }
    
    return 0;
}
```

## AcWing 876. 快速幂求逆元

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

typedef long long ll;

ll pmi(ll a, ll k, ll p)
{
    ll res = 1;
    while (k)
    {
        if (k & 1)  res = res * a % p;
        k >>= 1;
        a = a * a % p;
    }
    return res;
}

int main(void)
{
    int n;
    scanf("%d", &n);
    while (n --)
    {
        ll a, p;
        scanf("%lld%lld", &a, &p);
        if (a % p == 0) puts("impossible");
        else printf("%lld\n", pmi(a, p - 2, p));
    }
    
    return 0;
}
```

## AcWing 877. 扩展欧几里得算法
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

void exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1, y = 0;
        return;
    }
    exgcd(b, a % b, y, x);
    y -= a / b * x;
}

int main(void)
{
    int n;
    cin >> n;
    while (n --)
    {
        int a, b, x, y;
        scanf("%d%d", &a, &b);
        exgcd(a, b, x, y);
        printf("%d %d\n", x, y);
    }
    
    return 0;
}
```

## AcWing 878. 线性同余方程
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

int main(void)
{
    int n;
    cin >> n;
    while (n --)
    {
        int a, b, m, x, y;
        scanf("%d%d%d", &a, &b, &m);
        int d = exgcd(a, m, x, y);
        if (b % d)  puts("impossible");
        
        else printf("%d\n", b / (long long)d * x % m);
    }
    
    return 0;
}
```