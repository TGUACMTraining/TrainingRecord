## AcWing 866. 试除法判定质数
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;

bool is_prime(int x)
{
    if (x == 1) return false;
    for (int i = 2; i <= sqrt(x); i ++)
    {
        if (x % i == 0) return false;
    }
    return true;
}

int main(void)
{
    int n;
    cin >> n;
    while (n --)
    {
        int x;
        cin >> x;
        if (is_prime(x))    puts("Yes");
        else    puts("No");
    }
    
    return 0;
}
```

## AcWing 867. 分解质因数
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

void divide(int n)
{
    for (int i = 2; i <= n / i; i ++)   
    {
        if (n % i == 0)
        {
            int s = 0;
            while (n % i == 0)
            {
                n /= i;
                s ++;
            }
            printf("%d %d\n", i, s);
        }
    }
    
    if (n > 1)
    {
        printf("%d 1\n", n);
    }
    puts("");
}

int main(void)
{
    int t;
    scanf("%d", &t);
    while (t --)
    {
        int n;
        scanf("%d", &n);
        divide(n);
    }
    
    return 0;
}
```
## AcWing 868. 筛质数
### 埃氏筛
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 1000010;
bool primes[N];

int prime(int n)
{
    int res = 0;
    for (int i = 2; i <= n; i ++)
    {
        if (primes[i])  continue;
        else
        {
            res ++;
            for (int j = 1; j * i <= n; j ++)
            {
                primes[i*j] = true;
            }
        }
    }
    return res;
}

int main(void)
{
    int n;
    cin >> n;
    cout << prime(n) << endl;
    
    return 0;
}
```


### 线性筛
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 1000010;
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++)
    {
        if (!st[i]) primes[cnt ++] = i;
        for (int j = 0; primes[j] <= n / i; j ++)
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

int main(void)
{
    int n;
    cin >> n;
    
    get_primes(n);
    cout << cnt << endl;
    
    return 0;
}
```

## AcWing 869. 试除法求约数

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<vector>
using namespace std;

vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++)
    {
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i)
                res.push_back(x / i);
        }
    }
    return res;
}

int main(void)
{
    int t;
    cin >> t;
    while (t --)
    {
        int x;
        cin >> x;
        auto t = get_divisors(x);
        sort(t.begin(), t.end());
        for (auto gd : t)
        {
            printf("%d ", gd);
        }
        puts("");
    }
    
    return 0;
}
```

## AcWing 870. 约数个数
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<unordered_map>
using namespace std;

typedef long long ll;

const int mod = 1e9 + 7;
ll res = 1;

int main(void)
{
    int n;
    cin >> n;
    
    unordered_map<int, int> primes;
    
    while (n --)
    {
        int x;
        cin >> x;
        
        for (int i = 2; i <= x / i; i ++)
        {
            while (x % i == 0)
            {
                x /= i;
                primes[i] ++;
            }
        }
        if (x > 1)  primes[x] ++;
        
        
    }
    
    for (auto prime : primes)
    {
        res = res * (prime.second + 1) % mod;
    }
    
    cout << res << endl;
    
    return 0;
}
```

## AcWing 871. 约数之和
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<unordered_map>
using namespace std;

typedef long long ll;

const int mod = 1e9 + 7;
ll res = 1;

int main(void)
{
    int n;
    cin >> n;
    
    unordered_map<int, int> primes;
    
    while (n --)
    {
        int x;
        cin >> x;
        
        for (int i = 2; i <= x / i; i ++)
        {
            while (x % i == 0)
            {
                x /= i;
                primes[i] ++;
            }
        }
        if (x > 1)  primes[x] ++;
        
        
    }
    
    for (auto prime : primes)
    {
        ll a = prime.first, b = prime.second;
        ll t = 1;
        while (b --)
        {
            t = (t * a + 1) % mod;
        }
        res = res * t % mod;
    }
    
    cout << res << endl;
    
    return 0;
}
```

## AcWing 872. 最大公约数
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

int t;

int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

int main(void)
{
    cin >> t;
    while (t --)
    {
        int x, y;
        scanf("%d%d", &x, &y);
        printf("%d\n", gcd(x, y));
    }
    
    return 0;
}
```
## AcWing 196. 质数距离
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<climits>
using namespace std;

typedef long long ll;

const int N = 50010;
int primes[N], cnt;
bool st[N];

void is_primes(int n)
{
    for (int i = 2; i <= n; i ++)
    {
        if (!st[i])
        {
            primes[cnt ++] = i;
            
        }
        for (int j = 0; primes[j] <= n / i; j ++)
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

const int M = 1000010;
bool res[M];
int primes2[M], cnt2;

void check(ll l, ll r)
{
    for (int i = 0; i < cnt; i ++)
    {
        ll k = primes[i];
        ll j = max(2 * k, (l + k - 1) / k * k);
        if (k > r)  break;
        
        
        while (j <= r)
        {
            res[j - l] = true;
            j += k;
        }
    }
    if (l == 1) res[0] = true;
    
    for (ll i = l; i <= r; i ++)
    {
        if (!res[i - l])    primes2[cnt2 ++] = i;
    }
}

int main(void)
{
    is_primes(50010);
    ll l, r;
    while (~scanf("%lld%lld", &l, &r))
    {
        memset(res, 0, sizeof(res));
        memset(primes2, 0, sizeof(primes2));
        cnt2 = 0;
        
        check(l, r);
        
        if (cnt2 < 2)
        {
            puts("There are no adjacent primes.");
            continue;
        }
        
        pair<int, int> minp = {0, INT_MAX};
        pair<int, int> maxp = {0, 0};
        for (int i = 1; i < cnt2; i ++)
        {
            if (primes2[i] - primes2[i - 1] < minp.second - minp.first)
                minp = {primes2[i - 1], primes2[i]};
            if (primes2[i] - primes2[i - 1] > maxp.second - maxp.first)
                maxp = {primes2[i - 1], primes2[i]};
        }
        printf("%d,%d are closest, %d,%d are most distant.\n", minp.first, minp.second, maxp.first, maxp.second);
    }
    
    return 0;
}
```