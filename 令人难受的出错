数组根据查询要求来确定从0还是1开始读入

数组求和应优先考虑前缀和//二分答案时可能会遇到

<< &优先级低于+-*/
所以快读：
char*p;
template<class T> inline void read(register T &x){
    int flag=1;x=0;
    while(!isdigit(*p))(*p++)=='-'&&(flag=-1);
    while(isdigit(*p))x=(x<<3)+(x<<1)+(*p++&15);//此处注意&在括号内，然后"<<"要加括号
    x*=flag;
}
p=new char[caches_input];
fread(p,1,caches_input,stdin);
read(n),read(m);

结果保留优先用long long

通过差量法求值

提交时忘记关DBG模式

双堆操作的神奇食用方法{
    一个主要的堆，一个辅助的堆
    用辅助的堆调整主要的堆
}
template <class _Ty, class _Container = vector<_Ty>, class _Pr = less<typename _Container::value_type>>
struct pq{
    priority_queue<_Ty,_Container,_Pr>q;
    priority_queue<_Ty,_Container,_Pr>del;
    void refresh(){
        while(!del.empty()&&del.top()==q.top()){
            del.pop();
            q.pop();
        }
    }
    void push(int val){
        q.push(val);
        refresh();
    }
    void pop(int val){
        del.push(val);
        refresh();
    }
    int top(){
        refresh();
        return q.top();
    }
};//任意删除的高性能堆

存图:
1e5内
链式前向星快
1e5外
vector快(连续访问)