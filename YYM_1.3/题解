迭代器的显示逻辑和链表不太相同
接触了链表的基本操作
迭代器在指向链表最后一位后自增时会指向链表.end()，这时其实已经越界了，所以无法修改当前位置数据
在那之后继续自增就会回到链表的head
一般情况下string类还是比较靠谱的，运行起来比较快
getline(cin,str)不会读入最后一个\n
编程能力弱所以尽量不用现想的方法，尽量用成熟的方法
在进行组合时> >之间要加入空格，否则可能会被误认为右移
对于vector < list < int > > points应该先创建list<int> cache再挂载到points上去
优先队列自定义比较规则，
可以使用仿函数或者对被比较的类重载小于操作符。
由于C++规定操作符重载必须至少有一个类类型的操作数，
因此当优先队列中的元素不是自定义类的时候，
则没法对其重载小于操作符，
此时只能实用仿函数来实现自定义的比较规则。
cin的eof:
while (true)
{
    if ((std::cin >> word).eof())
    break;
    words.push(word);
}
note\string\hash\my_hash.cpp
对字符串的理解有了进一步的提升
对vector的应用有了进一步的提升
vector push_back时可能会使迭代器失效
以后与数组区间问题统一使用左闭右开的思想
注意过程量应是末状态量减去出状态量
位运算要多加括号，否则可能结果不是自己想要的
二分可能会出现很多奇怪的边界问题
分类讨论有时是非常简便的方法，虽然可能使代码量上涨，代码质量下降
数组记得开大一点，最好在调试时用一个固定好的较小的数组，提交时用new申请空间
这题完全不用一遍遍模拟，可以用数学手段解决
注意题目的范围
尽量不要使用magic number，
用const会让检查时更容易发现错误