## 洛谷 P2437 蜜蜂路线
类似与斐波那契数列
同样需要用高精度来计算
与楼梯类似

## 洛谷 P1164 小A点菜
最基本的01背包dp问题
考虑清楚二维的情况, 包括每一维度表示的是什么, 分成哪三种情况
之后降维, 由于是01背包, 因此j从后往前枚举
要注意令f0=1的操作, 理解其含义

## 洛谷 P1990 覆盖墙壁
找规律, 注意前几个不要找错
递推公式为ai = ai-1 * 2 + ai-3

## 洛谷 P3612 [USACO17JAN]Secret Cow Code S
还是类似于找规律的题目, 要注意每次倍增之后的字母在原序列中所在位置
根据要找的位置, 反推其位置即可
注意不可以用模拟的方法, 否则会爆空间

## Codeforces Round #693 (Div. 3) E. Correct Placement
题意: 给出n组数, 每组分为长和宽, 每个位置上如果存在长和宽均比当前位置小的数就可以放在这个位置之前, 求每个位置是否存在可放置的元素
本题一开始使用map来进行处理, 但是时间复杂度过高
赛后补题时采用了, 先将所有数据按a,b和b,a分别保存下来, 之后对h进行升序排列, h相同的按照w升序排列
然后从前往后遍历所有数据, 此时h已经保证了升序, 只需要对w与最大的宽度进行比较即可得到答案

## Codeforces Round #693 (Div. 3) G. Moving to the Capital
题意: 给出一个有向图, 图中1号点是主城, 主城到所有其他点有一个距离, 求每个点可以到达的距离主城的最短距离
要求: 
1. 如果从距离小的点向距离大的点走, 可以随意走
2. 否则, 只可以走一次这样的点
首先使用宽搜, 将所有点的距离保存下来,
之后, 当时想的是用dfs, 但是会超时(详见代码注释部分)
因此赛后使用dp对dfs进行了优化, 大体不变, 只是利用dp的思想不需要每一个点搜索一遍了
dp的思路就是, 如果当前点的距离小于要走的点, 则继续深搜, 直到搜到头, 再进行判断
若当前点距离小, 则从二者之间选一个最小值
否则, 从要走到的点和当前点的距离选一个最小值
是一道很不错的题目
